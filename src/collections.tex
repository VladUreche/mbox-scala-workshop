\section{Scala Collections}

% http://docs.scala-lang.org/overviews/collections/introduction.html

% what, why, how?

\topic{A collection defines the data structures and algorithms necessary to encapsulate data}. Every collection is tuned for a certain use case, thus balancing the heap space required with the time necessary for inserting, deleting or looking up elements. This gives rise to many tradeoffs, each with its own strengths and weaknesses.

\topic{Collections are an important toolbox for solving common problems}. Providing collections in a language's standard library serves multiple purposes: (1) it maximizes code reuse, as the collections are implemented only once and used extensively, (2) it allows programmers to focus on the core functionality of their program and (3) it allows standardizing around a the collections in the library when communicating between different libraries.

\topic{Collections in the standard library need to expose a simple and high-level interface while offering good performance.} The ease with which the programmers understand and use collections influences their adoption and thus whether code is reused and whether standardization occurs around collections. On the other hand, the extensive use of collections is only possible if the execution is efficient, so they do not become the bottleneck in a program.

\topic{Scala collections provide a high-level interface but lack in performance.} Scala collections offer a high-level interface, with expressive operations such as mapping and filtering standardized across all collections. They also abstract over the type of data in the collection by using generics. This provides ease of use, type safety and flexibility at the cost of a slower execution for primitive types, which require boxing and unboxing due to the erasure transformation.

\topic{In this paper we show how the miniboxing transformation enables improved colletions}, which expose the same high-level interface without sacrificing performance. The reason collections were not transformed with specialization, which predates miniboxing by 3 years, is twofold: (1) due to the important increase in bytecode size due to the transformation and (2) due to the mechanism used for class transformation, which leads to redundant fields in the specialized classes, thus unnecessarily doubling the heap requirements.

The next section will explain the common patterns that enable the high-level interface in the Scala collections.

% Since collections have become a popular toolbox for solving common problems,
% Scala needs to provide a set of them, so a programmer can reuse the
% same ones, without defining them over and over by himself. By providing such
% collections to the language, we also fix a semantic, so programmers all use the
% same interface, and understand each other.
%
% Thus, Scala collections need to be made in the most efficient way. They need
% to run fast, so the specific programmer doesn't need to reinvent the wheel each
% time he wants a better performance. In terms of performance, the implementation
% of such provided collections shouldn't be the bottleneck of a program.
%
% However, performance is not the only requirement for a collection. It should
% also provides a high-level interface to the user, so it only offers him a
% convenient way of using it, without knowing the exact implementation of it.
% Collections should also be generic, they should allow the user to choose the
% type he wants to contain. Conversions between them should be easy to apply, and
% comprehensions user-friendly.
%
% The problem with Scala collections lies between these two lines : performance
% and high-level interface. We should balance the two, and take the best
% compromise, so the collections are as convenient to use, and performant at the
% same time.


% draft
%
% Collections are a way to abstract data by regrouping it in a significant
% container. In a more common sense, they are like a toolbox for the programmer.
%
% Allow to store data in a convenient way. They are available by default in the
% language, so it offers the possibility to reuse them. They are able to run fast.
% They are standardized, which means that everyone knows how to interact and deal
% with them. And most important, they are implemented in a generic fashion, which
% allows to the user to use them in most general cases.
%
% why have collections in the library?
%  - reuse
%  - fast development (what's the meaning of this, already?)
%  - standardization (library interop)
%
% motivation
%  - high-level interface: generic, easy conversions, comprehensions
%  - performance: runtime aspect of the collections
%  - balance these 2
%
% talk about high-level:

\subsection{Collection Patterns}

Scala Collections use different patterns to expose their high-level interface consistently across all classes. Before we dive into optimizing, we need to know how collections are implemented in Scala, so we know where the plugin can be applied, and what gain it will bring. In this section, we will present only the most common patterns.

% In Scala, we have the high-level right\ldots
% Before we dive into optimizing, we will present the common patterns used in Collections.

\subsubsection{Inheritance and Mixins}

\topic{Inheritance and mixins group common behavior among different classes.} This reduces code duplication and gives rise to a convenient collection hierarchy, where each level of the inheritance makes more assumptions about the collection than the previous level. If a class shares the same behavior as another one, it extends it, therefore inheriting and refining the functionality. In order to reduce code duplication, we define general behaviors in the superclass, and we make all the subclasses that share this pattern inherit from it. A class can be an extension of only one superclass. If a subclass needs to inherit functionality from multiple classes, it can mix in different traits \cite{scalable-component-abstractions}. Unlike inheritance, mixin allows extending as many traits as necessary.

One of the key aims of the Scala collections is to reduce code duplication as much as possible. \topic{Instead of making a hierarchy of different collections, as in Java, Scala collections expose individual contracts in the form of traits.} These contracts are guaranteed to be respected thanks to the type system, thus allowing a very flexible choice of the characteristics of a collection. Every contract is signaled as a trait and the concrete implementation is inherited from the trait into the collection.

For example, a collection can offer a traversable contract, which guarantees all the elements contained in the collection can be visited. Mixing in the |Traversable| trait guarantees this propery by declaring an abstract |foreach| method, which collections must implement. Yet, traits can also contain implementations, and our collection can mix in different standard implementations of the |foreach| method, each optimized for a different type of collection, such as linear, indexed etc.

\subsubsection{Closure Encoding}

A closure refers to an open-term function that can to be closed by providing it a scope of variables. Closures in Scala are very frequently used, since they offer important characteristics, such as defining higher-order functions. In order to understand how a closure is encoded in the language, let's look at an example.

A closure that takes an |Int| as an argument and increments it by one is written in Scala as follows :

\begin{lstlisting-nobreak}
 (x: Int) => x + 1
\end{lstlisting-nobreak}

In Scala, it is common to use closures while dealing with of collections. A lot of functions in collections use closures, the most common ones being |filter|, |map| and |fold|. As a continuation of the previous example, if one wants to increment each element in a |List| of integers, he can pass the previously shown closure as a parameter in the |map| function. However, the Java Virtual Machine doesn't support closures (at least until the 7th version of Java). Therefore, Scala needs to provide them by using a separate encoding.

When the Scala Compiler meets a closure like the previous one, it will convert it as follows :

\begin{lstlisting-nobreak}
 {
  class $anonfun extends Function1[Int, Int] {
    def apply(x: Int) = x + 1
  }

  new $anonfun
 }
\end{lstlisting-nobreak}

This allows exposing functions to the first class citizens of the language. Now, instead of containing a closure in a value, the compiler actually stores an instance of the |$anonfun$| class. Therefore, such classes can be passed in parameters or be the type return of another function, thanks to the inheritance of the |Function1| trait. Note that this trait allows to encode general functions that takes only one parameter |T| and returns only one parameter |S|, in a generic setting :

\begin{lstlisting-nobreak}
 trait Function1[-T, +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

Since this function is generic, boxing and unboxing will occur if we use it with primitive types. Currently, |Function0|, |Function1| and |Function2| are specialized in the Scala Library, but we should get even better performance by using the Miniboxing plugin.

Therefore, instead of using common closures, we will define our own custom closures.

\begin{lstlisting-nobreak}
 abstract class MyFunction1[@miniboxed -T, @miniboxed +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

This will be called at every place we need to use closures. For instance, our custom |map| function from the |List| collection now takes an argument of type |MyFunction1| instead of a common closure |(T => S)|. However, every time we want to write a function, we will have to construct it manually. By example, |(x: Int) => x + 1| now becomes :

\begin{lstlisting-nobreak}
 new MyFunction1[Int, Int] {
   def apply(x: Int): Int = x + 1
 }
\end{lstlisting-nobreak}

Since the function |apply| is called whenever arguments follows an object, we can call this custom function by putting some value for |x| right after the instantiation. For convenience sake, let's show a complete example of a miniboxed function that maps every integer to a String, but contained in a value :

\begin{lstlisting-nobreak}
 val miniboxFun = new MyFunction1[Int, String] {
   def apply(x: Int): String = x.toString
 }

 miniboxFun(3)    // returns "3"
\end{lstlisting-nobreak}

\subsubsection{Builder Pattern}

The Builder pattern allows to create a new collection from the elements of an existing one. It grants the possibility to pass from a collection to another one, or to update the same one with different elements.

% by specifying to such functions a Builder that describes a way to build the new data structure from these elements. (How)

For instance, let's map the numbers of a |List| of integers to a |List| of Strings. One can use the |map| function of the collection |List| with the closure |(x: Int)| |=>| |"number " + x|. This will create a new |List| of the previous elements prepended with the text ``number'', but to achieve this, the |List| collection needs to know how to create a new |List| of String from the previous |List|. And this is provided by a builder, that will return the corresponding |List| if the requirements are met.

To achieve this, the |map| function will rely on another predefined function |mapTo|, that takes into parameter a Builder, and the user-supplied function.

\begin{lstlisting-nobreak}
 def mapTo[B, NewColl](f: A => B)(implicit bd: Builder[B, NewColl]): NewColl = {
   val builder = bd(repr)
   builder.sizeHint(this)
   val b = builder
   for (x <- this) b += f(x)
   b.result
 }
\end{lstlisting-nobreak}

To make it even more user-friendly, the builders are called implicitly, so the user doesn't even have to know about it to map his collection. Currently, in Scala, there's the |CanBuildFrom[From, Elem, To]| that allows to build collections. It's used with the parallel traits |CollectionLike| which is used to build, by default, the same collection has it has started from.

The Builder pattern also shows how type constructor polymorphism can play an essential role in factoring out boilerplate code without losing type safety.\cite{adriaan}

\subsubsection{Numeric Pattern}

Defining a generic type for a class can sometimes leads to inconvenient situations. Sometimes, one needs classes, such as |Matrix| and |Vector|, that depends only on numerical values. Due to the erasure of the JVM, generic objects don't offer many operations and functions, and it's therefore impossible to use mathematical operations on them.

The Numeric pattern solves this issue and allows generic types to somehow be treated as if they were numbers. Since a generic type is, by default, an extension of the top of the class hierarchy, we can't just cast the objects in different types to use them. This is solved by creating a generic Numeric trait that provides such operations :

\begin{lstlisting-nobreak}
 trait Numeric[T] {
   def minus(x: T, y: T): T
   def plus(x: T, y: T): T
   def mult(x: T, y: T): T
   def equals(x: T, y: T): Boolean

   def toInt(x: T): Int
   def toDouble(x: T): Double
 }
\end{lstlisting-nobreak}

Different extensions of this class are provided with different type parameters. We can write these specific classes only for the primitive ones that are numbers, i.e Byte, Short, Long, Int, Float, and Double, but we also could write it for any class, as long as these definitions are implemented. For instance, here's the code for the |Int| extension :

\begin{lstlisting-nobreak}
 implicit object NumericInt extends MyNumeric[Int] {
   def minus(x: Int, y: Int): Int = x - y
   def plus(x: Int, y: Int): Int = x + y
   def mult(x: Int, y: Int): Int = x * y
   def equals(x: Int, y: Int): Boolean = x == y

   def toInt(x: Int): Int = x
   def toDouble(x: Int): Double = x
 }
\end{lstlisting-nobreak}

Note that this object is made implicit, which means that our generic class should be able to find it by itself. Now, every time we want to use a generic as a numeric type, we force that the |Numeric| version of it exists, so we can call the mathematical operations on them. Hence, a |Matrix2x2| class could be written as follows :

\begin{lstlisting-nobreak}
 class Matrix2x2[T : Numeric](val a: T, val b: T, val c: T, val d: T) {

   def +(that: Matrix2x2[T]): Matrix2x2[T] = {
     val n = implicitly[Numeric[T]]
     new Matrix2x2[T](
       n.plus(this.a, that.a),
       n.plus(this.b, that.b),
       n.plus(this.c, that.c),
       n.plus(this.d, that.d))
   }

   def -(that: Matrix2x2[T]): Matrix2x2[T] = {
     val n = implicitly[Numeric[T]]
     new Matrix2x2[T](
       n.minus(this.a, that.a),
       n.minus(this.b, that.b),
       n.minus(this.c, that.c),
       n.minus(this.d, that.d))
   }
 }
\end{lstlisting-nobreak}
%    def *(that: Matrix2x2[T]): Matrix2x2[T] = {
%      val n = implicitly[Numeric[T]]
%      val newA = n.plus(
%        n.mult(this.a, that.a),
%        n.mult(this.b, that.c))
%      val newB = n.plus(
%        n.mult(this.a, that.b),
%        n.mult(this.b, that.d))
%      val newC = n.plus(
%        n.mult(this.c, that.a),
%        n.mult(this.d, that.c))
%      val newD = n.plus(
%        n.mult(this.c, that.b),
%        n.mult(this.d, that.d))
%
%       new Matrix2x2[T](newA, newB, newC, newD)
%    }
%  }
% \end{lstlisting-nobreak}

Thanks to this pattern, the duplication of code has been reduced, and we still have collections that offer high-level interface, and generic templates. But, since the |Numeric| also takes generic type parameter, and since it's most likely a primitive type, boxing and unboxing would occur a lot during the operations. This is where the Miniboxing specialization steps in. With a miniboxed version of the |Numeric| class, no boxes are made during the super-class instantiation. The generic classes that are also likely to get primitive types deal therefore only with type primitive, which speeds the runtime up.