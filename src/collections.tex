\section{Scala Collections}

% http://docs.scala-lang.org/overviews/collections/introduction.html

% what, why, how?

\topic{A collection, or an abstract data structure, defines a way to contain data within a single object (a container)}. Every collection has its own characteristics, that will determine its own strengths and weaknesses.

\topic{Collections are an important toolbox for solving common problems}. Providing such collections to the Scala language offers several advantages: the collections become standardized in the language, they can be used to develop software faster and conveniently, and a programmer can reuse the same ones over different projects.

\topic{There are 2 important criterias for writing collections: high-level interface, and performance.} Collections need to offer user-friendly methods to deal with them, so they are easy to use, but they also need to run fast in most of cases, so they do not create the bottleneck of a program. 

\topic{Scala collections provide high-level interface, but they lack in performance.} Due to the use of the Java Vitual Machine erasure, the process of boxing and unboxing for primitive types takes a significant amount of time. Therefore, the Miniboxing plugin should solve this problem, and make the Scala Collections efficient by specializing the collections used with primitive types.

% Since collections have become a popular toolbox for solving common problems,
% Scala needs to provide a set of them, so a programmer can reuse the
% same ones, without defining them over and over by himself. By providing such 
% collections to the language, we also fix a semantic, so programmers all use the
% same interface, and understand each other.
% 
% Thus, Scala collections need to be made in the most efficient way. They need
% to run fast, so the specific programmer doesn't need to reinvent the wheel each
% time he wants a better performance. In terms of performance, the implementation
% of such provided collections shouldn't be the bottleneck of a program.
% 
% However, performance is not the only requirement for a collection. It should
% also provides a high-level interface to the user, so it only offers him a
% convenient way of using it, without knowing the exact implementation of it.
% Collections should also be generic, they should allow the user to choose the
% type he wants to contain. Conversions between them should be easy to apply, and
% comprehensions user-friendly.
% 
% The problem with Scala collections lies between these two lines : performance
% and high-level interface. We should balance the two, and take the best
% compromise, so the collections are as convenient to use, and performant at the
% same time.


% draft
% 
% Collections are a way to abstract data by regrouping it in a significant
% container. In a more common sense, they are like a toolbox for the programmer.
% 
% Allow to store data in a convenient way. They are available by default in the
% language, so it offers the possibility to reuse them. They are able to run fast.
% They are standardized, which means that everyone knows how to interact and deal
% with them. And most important, they are implemented in a generic fashion, which
% allows to the user to use them in most general cases.
% 
% why have collections in the library?
%  - reuse
%  - fast development (what's the meaning of this, already?)
%  - standardization (library interop)
% 
% motivation
%  - high-level interface: generic, easy conversions, comprehensions
%  - performance: runtime aspect of the collections
%  - balance these 2
% 
% talk about high-level:

\subsection{Collection Patterns}

Many patterns are used in Scala Collections. Before we dive into optimizing, we need to know how collections are made in Scala, so we know where the plugin can be applied, and what gain it will bring. In this section, we will present only the most common ones that must be optimized by Miniboxing. 

% In Scala, we have the high-level right\ldots
% Before we dive into optimizing, we will present the common patterns used in Collections.

\subsubsection{Inheritance and Mixins}

\topic{Inheritance and mixins are a way to regroup common behavior and identical patterns between classes.} Since most of the collection share the same characteristics, it is natural to think of super class and traits to reduce code repetition.

Scala collections 

mixins \cite{scalable-component-abstractions}

\subsubsection{Closure Encoding}

A closure refers to an open-term function that can to be closed by providing it a scope of variables. Closures in Scala are very frequently used, since they offer important characteristics, such as defining higher-order functions. In order to understand how a closure is encoded in the language, let's look at an example.

A closure that takes an |Int| as an argument and increments it by one is written in Scala as follows :

\begin{lstlisting-nobreak}
 (x: Int) => x + 1
\end{lstlisting-nobreak}

In Scala, it is common to use closures while dealing with of collections. A lot of functions in collections use closures, the most common ones being |filter|, |map| and |fold|. As a continuation of the previous example, if one wants to increment each element in a |List| of integers, he can pass the previously shown closure as a parameter in the |map| function. However, the Java Virtual Machine doesn't support closures (at least until the 7th version of Java). Therefore, Scala needs to provide them by using a separate encoding.

When the Scala Compiler meets a closure like the previous one, it will convert it as follows :

\begin{lstlisting-nobreak}
 {
  class $anonfun extends Function1[Int, Int] {
    def apply(x: Int) = x + 1
  }
  
  new $anonfun
 }
\end{lstlisting-nobreak}

This allows exposing functions to the first class citizens of the language. Now, instead of containing a closure in a value, the compiler actually stores an instance of the |$anonfun$| class. Therefore, such classes can be passed in parameters or be the type return of another function, thanks to the inheritance of the |Function1| trait. Note that this trait allows to encode general functions that takes only one parameter |T| and returns only one parameter |S|, in a generic setting :

\begin{lstlisting-nobreak}
 trait Function1[-T, +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

Since this function is generic, boxing and unboxing will occur if we use it with primitive types. Currently, |Function0|, |Function1| and |Function2| are specialized in the Scala Library, but we should get even better performance by using the Miniboxing plugin.

Therefore, instead of using common closures, we will define our own custom closures. 

\begin{lstlisting-nobreak}
 trait MyFunction1[@miniboxed -T, @miniboxed +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

This will be called at every place we need to use closures. For instance, our custom |map| function from the |List| collection now takes an argument of type |MyFunction1| instead of a common closure |(T => S)|. However, everytime we want to write a function, we will have to construct it manually. By example, |(x: Int) => x + 1| now becomes :

\begin{lstlisting-nobreak}
 new MyFunction1[Int, Int] {
   def apply(x: Int): Int = x + 1
 }
\end{lstlisting-nobreak}

Since the function |apply| is called whenever arguments follows an object, we can call this custom function by putting some value for |x| right after the instanciation. In a more convenient fashion, let's show a complete example of a miniboxed function that maps every integer to a String, but contained in a value :

\begin{lstlisting-nobreak}
 val miniboxFun = new MyFunction1[Int, String] {
   def apply(x: Int): String = x.toString
 }
 
 miniboxFun(3)    // returns "3"
\end{lstlisting-nobreak}

\subsubsection{Builder Pattern}

The Builder pattern allows to create a new collection from the elements of an existing one. It grants the possibility to pass from a collection to another one, or to update the same one with different elements.

% by specifying to such functions a Builder that describes a way to build the new data structure from these elements. (How)

For instance, let's map the numbers of a |List| of integers to a |List| of Strings. One can use the |map| function of the collection |List| with the closure of |(x: Int) => "number " + x|. This will create a new |List| of the previous elements prepended with the text ``number'', but to achieve this, the |List| collection needs to know how to create a new |List| of String from the previous |List|. And this is provided by a builder, that will return the corresponding |List| if the requirements are met.

To achieve this, the |map| function will rely on another predefined function |mapTo|, that takes into parameter a Builder, and the user-supplied function.

<<code of mapTo, and map>>

%   def map[B, NewColl](f: A => B)(implicit bf: CanBuildFrom[Coll, B, NewColl]): NewColl = {
%     val bulilder = bf(repr)
%     bulilder.sizeHint(this)
%     val b = builder
%     for (x <- this) b += f(x)
%     b.result
%   }

To make it even more user-friendly, there are also implicit objects of builders, so the user doesn't even have to know about builders. Currently, in Scala, there's the |CanBuildFrom[From, Elem, To]| that 

The Builder pattern also shows how type constructor polymorphism can play an essential role in factoring out boilerplate code without losing type safety.\cite{adriaan}

\subsubsection{Numeric Pattern}

The Numeric pattern allows to use a generic type as if they were numerical.
Since there is no way of defining a type as numerical.
