\section{Scala Collections}

\topic{Scala collections provide a high-level interface but lack in performance.} Scala collections offer a high-level interface, with expressive operations such as mapping and filtering standardized across all collections. They also abstract over the type of data in the collection by using generics. This provides ease of use, type safety and flexibility at the cost of a slower execution for primitive types, which require boxing and unboxing due to the erasure transformation.

\topic{In this paper we show how the miniboxing transformation enables improved colletions}, which expose the same high-level interface without sacrificing performance. The next section presents the common patterns that enable the high-level interface in the Scala collections, and how miniboxing can be applied in order to improve performance.

\subsection{Collection Patterns}

Scala Collections use different patterns to expose their high-level interface consistently across all classes. Before we dive into optimizing, we need to know how collections are implemented in Scala, so we know where the plugin can be applied, and what gain it will bring. Note that we will present only the most common patterns.

\subsubsection{Inheritance and Mixins}

\topic{Inheritance and mixins group common behavior among different classes.} This reduces code duplication and gives rise to a convenient collection hierarchy, where each level of the inheritance makes more assumptions about the collection than the previous level.

One of the key aims of the Scala collections is to reduce code duplication as much as possible. \topic{Instead of making a hierarchy of different collections, as in Java, Scala collections expose individual contracts in the form of traits.} These contracts are guaranteed to be respected thanks to the type system, thus allowing a very flexible choice of the characteristics of a collection. Every contract is signaled as a trait and the concrete implementation is inherited from the trait into the collection.

Another group classes in the current hierarchy allows to build collections from an initial collection while dealing with them; \topic{these are the CollectionLike}. Along with the suitable builders, it allows to return the appropriate collection, depending on how we deal with them, without duplicating the exact same piece of code that only differs from the return type. This is done by extending a trait which abstracts over the return type of the different methods offered by collections. As an advantage, every collection that shares the exact same pattern can also extend it, as long as we provide the appropriate builders.

For example, a collection can offer a traversable contract, by mixing in the |Traversable| trait. Mixing in the |TraveresableLike| also guarantees this propery, and accords the possibility to build different collections from our current one, depending on what we do with them. Our collection can mix in different standard implementations, which are offered by different traits, each optimized for a different type of collection, such as linear, sorted, etc.

Since the elements of the CollectionLike can be primitive types, the methods can receive or return boxes of primitive values, which degrades performance. Thus, triggering the miniboxing plugin on the type parameter of the element offers better performance. However, we have to annote only the generic type of the elements contained in the collection, and not the type constructor. Indeed, since this is an abstraction over a container that will always be an object, there is no need to make an primitive type optimized version for it. Therefore, we get better performance if we use a custom CollectionLike with a |@miniboxed| notation on the type |T|:

\begin{lstlisting-nobreak}
 trait TraversableLike[-Coll, @miniboxed +T]
\end{lstlisting-nobreak}

\subsubsection{Closure Encoding}

In Scala, it is common to use closures while dealing with collections. A lot of functions in collections use closures, the most common ones being |filter|, |map| and |fold|. If one wants to increment each element in a |List| of integers, he can pass the following closure as a parameter in the |map| function:

\begin{lstlisting-nobreak}
 List(1,2,3).map(`x => x + 1`)
\end{lstlisting-nobreak}

However, the Java Virtual Machine doesn't support closures (at least until the 7th version of Java). Therefore, Scala needs to provide them by using a separate encoding.

When the Scala Compiler meets a closure like the previous one, it will convert it as follows :

\begin{lstlisting-nobreak}
 {
  class $anonfun extends Function1[Int, Int] {
    def apply(x: Int) = x + 1
  }

  new $anonfun
 }
\end{lstlisting-nobreak}

This allows exposing functions to the first class citizens of the language. In order to contain a closure in a value, the compiler actually stores an instance of the |\$anonfun| class. Therefore, such classes can be passed in parameters or be the type return of another function, thanks to type system. Note that this trait allows to encode general functions that takes only one parameter |T| and returns only one parameter |S|, in a generic setting:

\begin{lstlisting-nobreak}
 trait Function1[-T, +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

The function is used by calling |f.apply(1)|, which can be reduced to |f(1)|, thanks to Scala's syntactic sugar. Since this function is generic, boxing and unboxing will ensue if we use it with primitive types. Therefore, we should have better performance if we apply miniboxing on it.

Instead of using common Scala closures, we will define our own custom closures. Consequently, we will be able to annote each type parameter with the |@miniboxed| notation:

\begin{lstlisting-nobreak}
 trait MyFunc1[`@miniboxed` -T, `@miniboxed` +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

This will be called at every place we need to use closures. For instance, this is how we would encode and use a custom closure like |(x: Int) => x + 1|:

\begin{lstlisting-nobreak}
 val miniboxFun = new MyFunc1[Int, Int] {
   def apply(x: Int): Int = x + 1
 }

 miniboxFun(3)   // returns 4
\end{lstlisting-nobreak}

Also, in an implementation of |List[T]|, a custom |map| function would now be written as:

\begin{lstlisting-nobreak}
 def map[`@miniboxed S`](closure: MyFunc1[T, S])
\end{lstlisting-nobreak}

\subsubsection{Builder Pattern}

The Builder pattern allows to create a new collection from the elements of an existing one. It grants the possibility to pass from a collection to another one, or to update the same one with different elements.

% by specifying to such functions a Builder that describes a way to build the new data structure from these elements. (How)

For instance, let's map the numbers of a |List| of integers to a |List| of Strings. One can use the |map| function of the collection |List| with the closure |(x: Int)| |=>| |"number " + x|. This will create a new |List| of the previous elements prepended with the text ``number'', but to achieve this, the |List| collection needs to know how to create a new |List| of String from the previous |List|. And this is provided by a builder, that will return the corresponding |List| if the requirements are met.

To achieve this, the |map| function will rely on another predefined function |mapTo|, that takes into parameter a Builder, and the user-supplied function.

\begin{lstlisting-nobreak}
 def mapTo[B, NewColl](f: A => B)(implicit bd: Builder[B, NewColl]): NewColl = {
   val builder = bd(repr)
   builder.sizeHint(this)
   val b = builder
   for (x <- this) b += f(x)
   b.result
 }
\end{lstlisting-nobreak}

To make it even more user-friendly, the builders are called implicitly, so the user doesn't even have to know about it to map his collection. Currently, in Scala, there's the |CanBuildFrom[From, Elem, To]| that allows to build collections. It's used with the parallel traits |CollectionLike| which is used to build, by default, the same collection has it has started from.

The Builder pattern also shows how type constructor polymorphism can play an essential role in factoring out boilerplate code without losing type safety.\cite{adriaan}

\subsubsection{Numeric Pattern}

Defining a generic type for a class can sometimes leads to inconvenient situations. Sometimes, one needs classes that depends only on numerical values. Since there's no common ancestor for numeric types (primitive or object), it's impossible to specify an adequate upper bound for a generic type that would offer direct specific mathematical operations.

The Numeric pattern solves this issue and allows to use custom functions on type parameters. This is done by creating a generic |Numeric| trait that provides mathematical operations for a certain type. By example, one could define a way to add two numerical values, by providing such a definition to the trait:

\begin{lstlisting-nobreak}
 trait Numeric[T] {
   def plus(x: T, y: T): T
   ...
 }
\end{lstlisting-nobreak}

If we specify the trait into different concrete extensions, we provide a concrete implementation that defines the addition between two values. We can write these specific classes for primitive numbers, e.g |Int| or |Float|, but we also could write it for a numeric class, such as |BigInteger|, as long as the definition is implemented. For instance, here's the code for the |Int| extension:

\begin{lstlisting-nobreak}
 implicit object Num_I extends Numeric[Int] {
   def plus(x: Int, y: Int): Int = x + y
   ...
 }
\end{lstlisting-nobreak}

Now, every time we want to use a type parameter as a numeric type, we enforce that the |Numeric| version of the type exists, so we can call the mathematical operations on them. Here is a complete example of a two-dimensional vector:

\begin{lstlisting-nobreak}
 class Vec2D[T : Numeric](val x: T, val y: T) {
   def +(that: Vec2D[T]): Vec2D[T] = {
     val n = implicitly[Numeric[T]]
     new Vec2D[T](
       n.plus(this.x, that.x),
       n.plus(this.y, that.y))
   }
   ...
 }
\end{lstlisting-nobreak}

Since the |Numeric| implementations are likely to use primitive type parameters, boxing and unboxing would frequently occur. This is where the miniboxing specialization steps in. With a simple |@miniboxed| annotation on the type parameter of the |Numeric| class, a concrete extension would override an optimized version for primitive type. The classes that use the |Numeric| objects should also have a |@miniboxed| annotation. This would avoid every occurrence of boxing and unboxing, and enhance greatly the performance.