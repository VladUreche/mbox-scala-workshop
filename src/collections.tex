\section{Scala Collections}

% \topic{Scala collections provide a high-level interface but lack in performance.}

Scala collections offer a high-level interface, with expressive operations such as mapping and filtering standardized across all collections. They also abstract over the type of data in the collection by using generics. This provides ease of use, type safety and flexibility at the cost of a slower execution for primitive types, which require boxing and unboxing due to the erasure transformation.

\topic{In this paper we show how the miniboxing transformation improves collection performance} while exposing the same high-level interface.
%Scala Collections use different patterns to expose their high-level interface consistently across all classes.
Before we dive into optimizing, we will present the main patterns used to implement collections in Scala and how each of these patterns are transformed by the miniboxing transformation. % Note that we will present only the most common patterns.

\subsection{Inheritance and Mixins}

\topic{Inheritance and mixins group the common behavior of different collections.} This reduces code duplication and gives rise to a convenient collection hierarchy, where each level of the inheritance makes more assumptions about the architecture than the previous level. For example, the path to a linked list goes through |Traversable|, |Iterable|, |Seq|, |LinearSeq| and finally |List|. Each level makes an additional assumption: that the collection can be traversed, that it can be iterated, that it is a sequence, a linear sequence, and finally that it is a list.

This nesting and splitting of functionality makes is necessary to have deep miniboxing: Adding the |@miniboxed| annotation to a collection type parameter will not be enough to fully transform it, as most of its functionality will be inherited from parent traits. Instead, what needs to be done is to deeply visit all the parent traits and mark their arguments as |@miniboxed|:

\begin{lstlisting-nobreak}
 // trait/class definition needs to be marked:
 trait Traversable[`@miniboxed` +A] extends
 // parents' definitions also have to be marked:
       TraversableLike[`A`, Traversable[A]]
       with GenTraversable[`A`]
       with TraversableOnce[`A`]
       with GenericTraversableTemplate[`A`, Traversable] { ... }
\end{lstlisting-nobreak}

%Since the elements of the CollectionLike can be primitive types, the methods implemented can receive or return boxes of primitive values, which degrades performance. Thus, triggering the miniboxing plugin on the type parameter of the element offers better performance. However, we have to annote only the generic type of the elements contained in the collection, and not the type constructor. Indeed, since this is an abstraction over a container that will always be an object, there is no need to make a primitive type optimized version for it. Therefore, we get better performance if we use a custom CollectionLike with a |@miniboxed| notation on the type |T|:

Since the goal of Scala collections is to avoid code duplication, collection comprehensions, such as |map| and |filter|, all rely on a common mechanism: visiting each element in the collection, performing an action for it, and optionally adding a new element to the result collection. For example, |filter| visits all elements and for each element applies a predicate which decides whether the element should be part of the resulting collection or not.

The two key elements necessary for implementing collection comprehensions are: (1) the mechanism to visit each element using a custom closure, which is implemented in |Traversable| and (2) a mechanism to build a collection element by element, which is the builder pattern. We will also present the Numeric pattern, which is used in methods like |max|, |min| or |sum|.

\subsection{Closure Encoding}

In Scala, it is common to use closures while dealing with collections. A lot of functions in collections use closures, the most common ones being |filter|, |map| and |fold|. For example, if one wants to filter positive numbers in a |List| of integers, he can use the |filter| method along with the following closure:

\begin{lstlisting-nobreak}
 List[Int](-1,0,1).filter(`x => x > 0`)
\end{lstlisting-nobreak}

However, since the Java Virtual Machine doesn't support closures (at least until the 7th version of Java), Scala needs to provide them by using a separate encoding, that we can't directly override with Miniboxing. Hence, in order to specialize closures, we need to provide custom ones, so we can use optimized version of them.

This is done by creating a custom |MyFunc1| trait that will describe our new closure. This trait receives two type parameters that describe the type translation of our closure, i.e |(T => S)|. It also offers an abstract |apply| function that will contain the actual code of the closure. Miniboxing is triggered by annoting both of the type parameters with |@miniboxed|:

\begin{lstlisting-nobreak}
 trait MyFunc1[`@miniboxed` -T, `@miniboxed` +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

The plugin will transform this trait into an abstract trait, that will define the interface for the specialized classes. Along with the erasure-based version, four different methods will be made ; each one describing a combination of whether the type parameters |T| and |S| are primitive or references:

\begin{lstlisting-nobreak}
  abstract trait MyFunc1[-T, +S] extends Object {
    def `apply`(t: T): S
    def `apply_JJ`(T_TypeTag: Byte,
        S_TypeTag: Byte, t: long): long
    def `apply_JL`(T_TypeTag: Byte, t: long): S
    def `apply_LJ`(S_TypeTag: Byte, t: T): long
  }
\end{lstlisting-nobreak}

Then, four different abstract traits that extend the previous interface will be made. Here is the optimized version for primitive type for both type parameters |T| and |S|:

\begin{lstlisting-nobreak}
  abstract trait `MyFunc1_JJ`[-Tsp, +Ssp] extends MyFunc1[Tsp,Ssp] {
    def $S_TypeTag(): Byte
    def $T_TypeTag(): Byte
    def apply(t: Tsp): Ssp
    def apply_JJ(T_TypeTag: Byte, S_TypeTag: Byte, t: long): long
    def apply_JL(T_TypeTag: Byte, t: long): Ssp
    def apply_LJ(S_TypeTag: Byte, t: Tsp): long
  }

\end{lstlisting-nobreak}

Note that only the |apply_JJ| is used in this case, since it determines the optimized version when both of the type parameters are primitive types. The others methods, especially |apply|, only forward to this method.

Now, if one instantiates |MyFunc1[T,S]| with both primitive types for |T| and |S| and provides an implementation for the |apply| method, the class will actually override the |MyFunc1_JJ| abstract trait, and the implementation will be provided to |apply_JJ|. Since the function |apply_JJ| offers direct primitive types instead of references for arguments and return type, it will greatly enhance performance by avoiding boxing and unboxing processes.

\subsection{Builder Pattern}

The Builder pattern allows to create a new collection from the elements of an existing one. The pattern greatly reduce code duplication, when the methods differs only in their return types. To achieve this, a builder that contains the implementation of the creation of collections is provided to methods that returns such collections.

% by specifying to such functions a Builder that describes a way to build the new data structure from these elements. (How)

For instance, if one maps the elements of a |Map[Int, Int]| to some new combination |Long| |->| |Byte|, then the method should return a |Map[Double, String]|. But if one wants to map the key-value tuple to a single |Short| value, then it makes sense that the return type is no more a |Map|, but some |Iterable| collection, like a |List[Short]|. In other words:

\begin{lstlisting-nobreak}
 Map[Int,Int].map(f:(Int,Int) => (Long,Byte))
      // returns a Map[Long,Byte]
 Map[Int,Int].map(f:(Int,Int) => Short)
      // returns an Iterable[Short]
\end{lstlisting-nobreak}

To achieve this, the |map| function will rely on another predefined function |mapTo|, that takes into parameter a Builder, and the user-supplied function.

\begin{lstlisting-nobreak}
 def mapTo[B, NewColl](f: A => B)(implicit bd: Builder[B, NewColl]): NewColl = {
   val builder = bd(repr)
   builder.sizeHint(this)
   val b = builder
   for (x <- this) b += f(x)
   b.result
 }
\end{lstlisting-nobreak}



The Builder pattern also shows how type constructor polymorphism can play an essential role in factoring out boilerplate code without losing type safety.\cite{adriaan}

\subsection{Numeric Pattern}

Defining a generic type for a class can sometimes leads to inconvenient situations. Sometimes, one needs classes that depends only on numerical values. Since there's no common ancestor for numeric types (primitive or object), it's impossible to specify an adequate upper bound for a generic type that would directly offer mathematical operations.

The Numeric pattern solves this issue and allows to use custom functions on type parameters. This is done by creating a generic |Numeric| trait that provides mathematical operations for a certain type. By example, one could define a way to add two numerical values, by providing such a definition to the trait:

\begin{lstlisting-nobreak}
 trait Numeric[T] {
   def plus(x: T, y: T): T
   ...
 }
\end{lstlisting-nobreak}

If we specify the trait into different concrete extensions, we provide a concrete implementation that defines the addition between two values. We can write these specific classes for primitive numbers, e.g |Int| or |Float|, but we also could write it for a numeric class, such as |BigInteger|, as long as the definition is implemented. For instance, here's the code for the |Int| extension:

\begin{lstlisting-nobreak}
 implicit object Num_I extends Numeric[Int] {
   def plus(x: Int, y: Int): Int = x + y
   ...
 }
\end{lstlisting-nobreak}

Now, every time we want to use a type parameter as a numeric type, we enforce that the |Numeric| version of the type exists, so we can call the mathematical operations on them. Here is a complete example of a two-dimensional vector class:

\begin{lstlisting-nobreak}
 class Vec2D[T : Numeric](val x: T, val y: T) {
   def +(that: Vec2D[T]): Vec2D[T] = {
     val n = implicitly[Numeric[T]]
     new Vec2D[T](
       n.plus(this.x, that.x),
       n.plus(this.y, that.y))
   }
   ...
 }
\end{lstlisting-nobreak}

Since the |Numeric| implementations are likely to use primitive type parameters, boxing and unboxing would frequently occur. This is where the miniboxing specialization steps in. With a simple |@miniboxed| annotation on the type parameter of the |Numeric| class, a concrete extension would override an optimized version for primitive type. The classes that use the |Numeric| objects should also have a |@miniboxed| annotation. This would avoid every occurrence of boxing and unboxing, and enhance greatly the performance.