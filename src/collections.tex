\section{Scala Collections}

\topic{Scala collections provide a high-level interface but lack in performance.} Scala collections offer a high-level interface, with expressive operations such as mapping and filtering standardized across all collections. They also abstract over the type of data in the collection by using generics. This provides ease of use, type safety and flexibility at the cost of a slower execution for primitive types, which require boxing and unboxing due to the erasure transformation.

\topic{In this paper we show how the miniboxing transformation enables improved colletions}, which expose the same high-level interface without sacrificing performance. The next section presents the common patterns that enable the high-level interface in the Scala collections, and how miniboxing can be applied in order to improve performance.

\subsection{Collection Patterns}

Scala Collections use different patterns to expose their high-level interface consistently across all classes. Before we dive into optimizing, we need to know how collections are implemented in Scala, so we know where the plugin can be applied, and what gain it will bring. Note that we will present only the most common patterns.

\subsubsection{Inheritance and Mixins}

\topic{Inheritance and mixins group common behavior among different classes.} This reduces code duplication and gives rise to a convenient collection hierarchy, where each level of the inheritance makes more assumptions about the collection than the previous level.

One of the key aims of the Scala collections is to reduce code duplication as much as possible. \topic{Instead of making a hierarchy of different collections, as in Java, Scala collections expose individual contracts in the form of traits.} These contracts are guaranteed to be respected thanks to the type system, thus allowing a very flexible choice of the characteristics of a collection. Every contract is signaled as a trait and the concrete implementation is inherited from the trait into the collection.

For example, a collection can offer a traversable contract, which guarantees all the elements contained in the collection can be visited. Mixing in the |Traversable| trait guarantees this propery by declaring an abstract |foreach| method, which collections must implement. Yet, traits can also contain implementations, and our collection can mix in different standard implementations of the |foreach| method, each optimized for a different type of collection, such as linear, indexed etc.

\subsubsection{Closure Encoding}

In Scala, it is common to use closures while dealing with collections. A lot of functions in collections use closures, the most common ones being |filter|, |map| and |fold|. If one wants to increment each element in a |List| of integers, he can pass the following closure as a parameter in the |map| function:

\begin{lstlisting-nobreak}
 List(1,2,3).map(`(x: Int) => x + 1`)
\end{lstlisting-nobreak}

 However, the Java Virtual Machine doesn't support closures (at least until the 7th version of Java). Therefore, Scala needs to provide them by using a separate encoding.

When the Scala Compiler meets a closure like the previous one, it will convert it as follows :

\begin{lstlisting-nobreak}
 {
  class $anonfun extends Function1[Int, Int] {
    def apply(x: Int) = x + 1
  }

  new $anonfun
 }
\end{lstlisting-nobreak}

This allows exposing functions to the first class citizens of the language. In order to contain a closure in a value, the compiler actually stores an instance of the |\$anonfun| class. Therefore, such classes can be passed in parameters or be the type return of another function, thanks to type system. Note that this trait allows to encode general functions that takes only one parameter |T| and returns only one parameter |S|, in a generic setting :

\begin{lstlisting-nobreak}
 trait Function1[-T, +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

Since this function is generic, boxing and unboxing will ensue if we use it with primitive types. Therefore, we should have better performance if we apply miniboxing on it.

Instead of using common Scala closures, we will define our own custom closures. Consequently, we will be able to annote them with the |@miniboxed| notation.

\begin{lstlisting-nobreak}
 abstract class MyFunction1[`@miniboxed` -T, `@miniboxed` +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

This will be called at every place we need to use closures. For instance, this is how we would encode and use a custom closure like |(x: Int) => x + 1|:

\begin{lstlisting-nobreak}
 val miniboxFun = new MyFunction1[Int, Int] {
   def apply(x: Int): Int = x + 1
 }

 miniboxFun(3)   // returns 4
\end{lstlisting-nobreak}

And a custom |map| function would now take an argument of type |MyFunction1[T,S]| in an implementation of |List[T]|:

\begin{lstlisting-nobreak}
 def map[`@miniboxed S`](closure: MyFunction[T, S])
\end{lstlisting-nobreak}

\subsubsection{Builder Pattern}

The Builder pattern allows to create a new collection from the elements of an existing one. It grants the possibility to pass from a collection to another one, or to update the same one with different elements.

% by specifying to such functions a Builder that describes a way to build the new data structure from these elements. (How)

For instance, let's map the numbers of a |List| of integers to a |List| of Strings. One can use the |map| function of the collection |List| with the closure |(x: Int)| |=>| |"number " + x|. This will create a new |List| of the previous elements prepended with the text ``number'', but to achieve this, the |List| collection needs to know how to create a new |List| of String from the previous |List|. And this is provided by a builder, that will return the corresponding |List| if the requirements are met.

To achieve this, the |map| function will rely on another predefined function |mapTo|, that takes into parameter a Builder, and the user-supplied function.

\begin{lstlisting-nobreak}
 def mapTo[B, NewColl](f: A => B)(implicit bd: Builder[B, NewColl]): NewColl = {
   val builder = bd(repr)
   builder.sizeHint(this)
   val b = builder
   for (x <- this) b += f(x)
   b.result
 }
\end{lstlisting-nobreak}

To make it even more user-friendly, the builders are called implicitly, so the user doesn't even have to know about it to map his collection. Currently, in Scala, there's the |CanBuildFrom[From, Elem, To]| that allows to build collections. It's used with the parallel traits |CollectionLike| which is used to build, by default, the same collection has it has started from.

The Builder pattern also shows how type constructor polymorphism can play an essential role in factoring out boilerplate code without losing type safety.\cite{adriaan}

\subsubsection{Numeric Pattern}

Defining a generic type for a class can sometimes leads to inconvenient situations. Sometimes, one needs classes, such as |Matrix| and |Vector|, that depends only on numerical values. Due to the erasure of the JVM, generic objects don't offer many operations and functions, and it's therefore impossible to use mathematical operations on them.

The Numeric pattern solves this issue and allows generic types to somehow be treated as if they were numbers. Since a generic type is, by default, an extension of the top of the class hierarchy, we can't just cast the objects in different types to use them. This is solved by creating a generic Numeric trait that provides such operations :

\begin{lstlisting-nobreak}
 trait Numeric[T] {
   def minus(x: T, y: T): T
   def plus(x: T, y: T): T
   def mult(x: T, y: T): T
   def equals(x: T, y: T): Boolean

   def toInt(x: T): Int
   def toDouble(x: T): Double
 }
\end{lstlisting-nobreak}

Different extensions of this class are provided with different type parameters. We can write these specific classes only for the primitive ones that are numbers, i.e Byte, Short, Long, Int, Float, and Double, but we also could write it for any class, as long as these definitions are implemented. For instance, here's the code for the |Int| extension :

\begin{lstlisting-nobreak}
 implicit object NumericInt extends MyNumeric[Int] {
   def minus(x: Int, y: Int): Int = x - y
   def plus(x: Int, y: Int): Int = x + y
   def mult(x: Int, y: Int): Int = x * y
   def equals(x: Int, y: Int): Boolean = x == y

   def toInt(x: Int): Int = x
   def toDouble(x: Int): Double = x
 }
\end{lstlisting-nobreak}

Note that this object is made implicit, which means that our generic class should be able to find it by itself. Now, every time we want to use a generic as a numeric type, we force that the |Numeric| version of it exists, so we can call the mathematical operations on them. Hence, a |Matrix2x2| class could be written as follows :

\begin{lstlisting-nobreak}
 class Matrix2x2[T : Numeric](val a: T, val b: T, val c: T, val d: T) {

   def +(that: Matrix2x2[T]): Matrix2x2[T] = {
     val n = implicitly[Numeric[T]]
     new Matrix2x2[T](
       n.plus(this.a, that.a),
       n.plus(this.b, that.b),
       n.plus(this.c, that.c),
       n.plus(this.d, that.d))
   }

   def -(that: Matrix2x2[T]): Matrix2x2[T] = {
     val n = implicitly[Numeric[T]]
     new Matrix2x2[T](
       n.minus(this.a, that.a),
       n.minus(this.b, that.b),
       n.minus(this.c, that.c),
       n.minus(this.d, that.d))
   }
 }
\end{lstlisting-nobreak}
%    def *(that: Matrix2x2[T]): Matrix2x2[T] = {
%      val n = implicitly[Numeric[T]]
%      val newA = n.plus(
%        n.mult(this.a, that.a),
%        n.mult(this.b, that.c))
%      val newB = n.plus(
%        n.mult(this.a, that.b),
%        n.mult(this.b, that.d))
%      val newC = n.plus(
%        n.mult(this.c, that.a),
%        n.mult(this.d, that.c))
%      val newD = n.plus(
%        n.mult(this.c, that.b),
%        n.mult(this.d, that.d))
%
%       new Matrix2x2[T](newA, newB, newC, newD)
%    }
%  }
% \end{lstlisting-nobreak}

Thanks to this pattern, the duplication of code has been reduced, and we still have collections that offer high-level interface, and generic templates. But, since the |Numeric| also takes generic type parameter, and since it's most likely a primitive type, boxing and unboxing would occur a lot during the operations. This is where the Miniboxing specialization steps in. With a miniboxed version of the |Numeric| class, no boxes are made during the super-class instantiation. The generic classes that are also likely to get primitive types deal therefore only with type primitive, which speeds the runtime up.