\section{Scala Collections}

% http://docs.scala-lang.org/overviews/collections/introduction.html

% what, why, how?

\topic{A collection, or an abstract data structure, defines a way to contain data within a single object (a container)}. Every collection has its own characteristics, that will determine its own strengths and weaknesses.

\topic{Collections are an important toolbox for solving common problems}. Providing such collections to the Scala language offers several advantages: the collections become standardized in the language, they can be used to develop software faster and conveniently, and a programmer can reuse the same ones over different projects.

\topic{There are 2 important criterias for writing collections: high-level interface, and performance.} Collections need to offer user-friendly methods to deal with them, so they are easy to use, but they also need to run fast in most of cases, so they do not create the bottleneck of a program. 

\topic{Scala collections provide high-level interface, but they lack in performance.} Due to the use of the Java Vitual Machine erasure, the process of boxing and unboxing for primitive types takes a significant amount of time. Therefore, the Miniboxing plugin should solve this problem, and make the Scala Collections efficient by specializing the collections used with primitive types.

% Since collections have become a popular toolbox for solving common problems,
% Scala needs to provide a set of them, so a programmer can reuse the
% same ones, without defining them over and over by himself. By providing such 
% collections to the language, we also fix a semantic, so programmers all use the
% same interface, and understand each other.
% 
% Thus, Scala collections need to be made in the most efficient way. They need
% to run fast, so the specific programmer doesn't need to reinvent the wheel each
% time he wants a better performance. In terms of performance, the implementation
% of such provided collections shouldn't be the bottleneck of a program.
% 
% However, performance is not the only requirement for a collection. It should
% also provides a high-level interface to the user, so it only offers him a
% convenient way of using it, without knowing the exact implementation of it.
% Collections should also be generic, they should allow the user to choose the
% type he wants to contain. Conversions between them should be easy to apply, and
% comprehensions user-friendly.
% 
% The problem with Scala collections lies between these two lines : performance
% and high-level interface. We should balance the two, and take the best
% compromise, so the collections are as convenient to use, and performant at the
% same time.


% draft
% 
% Collections are a way to abstract data by regrouping it in a significant
% container. In a more common sense, they are like a toolbox for the programmer.
% 
% Allow to store data in a convenient way. They are available by default in the
% language, so it offers the possibility to reuse them. They are able to run fast.
% They are standardized, which means that everyone knows how to interact and deal
% with them. And most important, they are implemented in a generic fashion, which
% allows to the user to use them in most general cases.
% 
% why have collections in the library?
%  - reuse
%  - fast development (what's the meaning of this, already?)
%  - standardization (library interop)
% 
% motivation
%  - high-level interface: generic, easy conversions, comprehensions
%  - performance: runtime aspect of the collections
%  - balance these 2
% 
% talk about high-level:

\subsection{Collection Patterns}

Many patterns are used in Scala Collections. Before we dive into optimizing, we need to know how collections are made in Scala, so we know where the plugin can be applied, and what gain it will bring. In this section, we will present only the most common ones that must be optimized by Miniboxing. 

% In Scala, we have the high-level right\ldots
% Before we dive into optimizing, we will present the common patterns used in Collections.

\subsubsection{Inheritance and Mixins}

\topic{Inheritance and mixins are a way to regroup common behavior and identical patterns between classes.} It allows to reduce code duplication and to hierarchize the collections. If a class shares the same behavior as another one, it can extends it, and therefore inherits its functions. The class that inherits from another one becomes a sublcass, and the one that is extended becomes a superclass. In order to reduce code duplication, we define general behaviors in the superclass, and we make all the subclasses that share this pattern inherit from it. A class can be an extension of only one superclass. If a subclass needs to inherits functions from multiple classes, we use mixin. Unlike inheritance, mixin allows to inherit from as many traits as we want.

With these tools available, Scala collections are written to reduce code duplication as maximum as possible. \topic{Instead of hierarchizing the different collections, as in Java, Scala collections hierarchize the aspects that a collection can offer.} It allows to provide contracts to the user and to the programmer, so an instance of a specific aspect is guaranteed to meet the specific characteristic. Therefore, it offers a very flexible control of the characteristics that a programmer wants for a collection. Every aspect is described as a single trait or abstract class, and a concrete implementation inherits of these multiple aspects if it provides the promised characteristics.

For instance, a collection can offer a traversable aspect, i.e one can look upon all the elements contained in the collection. Therefore, the |Traversable| trait is made to offer such a characteristic. If a collection uses the |Traversable| trait, it is guaranteed that one can traverse all the elements of the collection, as long as the collection implements a version of the |foreach| function, which is provided by default by the trait.



mixins \cite{scalable-component-abstractions}

\subsubsection{Closure Encoding}

A closure refers to an open-term function that can to be closed by providing it a scope of variables. Closures in Scala are very frequently used, since they offer important characteristics, such as defining higher-order functions. In order to understand how a closure is encoded in the language, let's look at an example.

A closure that takes an |Int| as an argument and increments it by one is written in Scala as follows :

\begin{lstlisting-nobreak}
 (x: Int) => x + 1
\end{lstlisting-nobreak}

In Scala, it is common to use closures while dealing with of collections. A lot of functions in collections use closures, the most common ones being |filter|, |map| and |fold|. As a continuation of the previous example, if one wants to increment each element in a |List| of integers, he can pass the previously shown closure as a parameter in the |map| function. However, the Java Virtual Machine doesn't support closures (at least until the 7th version of Java). Therefore, Scala needs to provide them by using a separate encoding.

When the Scala Compiler meets a closure like the previous one, it will convert it as follows :

\begin{lstlisting-nobreak}
 {
  class $anonfun extends Function1[Int, Int] {
    def apply(x: Int) = x + 1
  }
  
  new $anonfun
 }
\end{lstlisting-nobreak}

This allows exposing functions to the first class citizens of the language. Now, instead of containing a closure in a value, the compiler actually stores an instance of the |$anonfun$| class. Therefore, such classes can be passed in parameters or be the type return of another function, thanks to the inheritance of the |Function1| trait. Note that this trait allows to encode general functions that takes only one parameter |T| and returns only one parameter |S|, in a generic setting :

\begin{lstlisting-nobreak}
 trait Function1[-T, +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

Since this function is generic, boxing and unboxing will occur if we use it with primitive types. Currently, |Function0|, |Function1| and |Function2| are specialized in the Scala Library, but we should get even better performance by using the Miniboxing plugin.

Therefore, instead of using common closures, we will define our own custom closures. 

\begin{lstlisting-nobreak}
 abstract class MyFunction1[@miniboxed -T, @miniboxed +S] {
   def apply(t: T): S
 }
\end{lstlisting-nobreak}

This will be called at every place we need to use closures. For instance, our custom |map| function from the |List| collection now takes an argument of type |MyFunction1| instead of a common closure |(T => S)|. However, every time we want to write a function, we will have to construct it manually. By example, |(x: Int) => x + 1| now becomes :

\begin{lstlisting-nobreak}
 new MyFunction1[Int, Int] {
   def apply(x: Int): Int = x + 1
 }
\end{lstlisting-nobreak}

Since the function |apply| is called whenever arguments follows an object, we can call this custom function by putting some value for |x| right after the instantiation. For convenience sake, let's show a complete example of a miniboxed function that maps every integer to a String, but contained in a value :

\begin{lstlisting-nobreak}
 val miniboxFun = new MyFunction1[Int, String] {
   def apply(x: Int): String = x.toString
 }
 
 miniboxFun(3)    // returns "3"
\end{lstlisting-nobreak}

\subsubsection{Builder Pattern}

The Builder pattern allows to create a new collection from the elements of an existing one. It grants the possibility to pass from a collection to another one, or to update the same one with different elements.

% by specifying to such functions a Builder that describes a way to build the new data structure from these elements. (How)

For instance, let's map the numbers of a |List| of integers to a |List| of Strings. One can use the |map| function of the collection |List| with the closure of |(x: Int) => "number " + x|. This will create a new |List| of the previous elements prepended with the text ``number'', but to achieve this, the |List| collection needs to know how to create a new |List| of String from the previous |List|. And this is provided by a builder, that will return the corresponding |List| if the requirements are met.

To achieve this, the |map| function will rely on another predefined function |mapTo|, that takes into parameter a Builder, and the user-supplied function.

<<code of mapTo, and map>>

%   def map[B, NewColl](f: A => B)(implicit bf: CanBuildFrom[Coll, B, NewColl]): NewColl = {
%     val bulilder = bf(repr)
%     bulilder.sizeHint(this)
%     val b = builder
%     for (x <- this) b += f(x)
%     b.result
%   }

To make it even more user-friendly, there are also implicit objects of builders, so the user doesn't even have to know about builders. Currently, in Scala, there's the |CanBuildFrom[From, Elem, To]| that 

The Builder pattern also shows how type constructor polymorphism can play an essential role in factoring out boilerplate code without losing type safety.\cite{adriaan}

\subsubsection{Numeric Pattern}

Defining a generic type for a class can sometimes leads to inconvenient situations. Sometimes, one needs classes, such as |Matrix| and |Vector|, that depends only on numerical values. Due to the erasure of the JVM, generic objects don't offer many operations and functions, and it's therefore impossible to use mathematical operations on them.

The Numeric pattern solves this issue and allows generic types to somehow be treated as if they were numbers. Since a generic type is, by default, an extension of the top of the class hierarchy, we can't just cast the objects in different types to use them. This is solved by creating a generic Numeric trait that provides such operations :

\begin{lstlisting-nobreak}
 trait Numeric[T] {
   def minus(x: T, y: T): T
   def plus(x: T, y: T): T
   def mult(x: T, y: T): T
   def equals(x: T, y: T): Boolean
   
   def toInt(x: T): Int
   def toDouble(x: T): Double
 }
\end{lstlisting-nobreak}

Different extensions of this class are provided with different type parameters. We can write these specific classes only for the primitive ones that are numbers, i.e Byte, Short, Long, Int, Float, and Double, but we also could write it for any class, as long as these definitions are implemented. For instance, here's the code for the |Int| extension :

\begin{lstlisting-nobreak}
 implicit object NumericInt extends MyNumeric[Int] {
   def minus(x: Int, y: Int): Int = x - y
   def plus(x: Int, y: Int): Int = x + y
   def mult(x: Int, y: Int): Int = x * y
   def equals(x: Int, y: Int): Boolean = x == y
   
   def toInt(x: Int): Int = x
   def toDouble(x: Int): Double = x
 }
\end{lstlisting-nobreak}

Note that this object is made implicit, which means that our generic class should be able to find it by itself. Now, every time we want to use a generic as a numeric type, we force that the |Numeric| version of it exists, so we can call the mathematical operations on them. Hence, a |Matrix2x2| class could be written as follows :

\begin{lstlisting-nobreak}
 class Matrix2x2[T : Numeric](val a: T, val b: T, val c: T, val d: T) {
 
   def +(that: Matrix2x2[T]): Matrix2x2[T] = {
     val n = implicitly[Numeric[T]]
     new Matrix2x2[T](
       n.plus(this.a, that.a),
       n.plus(this.b, that.b),
       n.plus(this.c, that.c),
       n.plus(this.d, that.d))
   }
   
   def -(that: Matrix2x2[T]): Matrix2x2[T] = {
     val n = implicitly[Numeric[T]]
     new Matrix2x2[T](
       n.minus(this.a, that.a),
       n.minus(this.b, that.b),
       n.minus(this.c, that.c),
       n.minus(this.d, that.d))
   }
 }
\end{lstlisting-nobreak}
%    def *(that: Matrix2x2[T]): Matrix2x2[T] = {
%      val n = implicitly[Numeric[T]]
%      val newA = n.plus(
%        n.mult(this.a, that.a),
%        n.mult(this.b, that.c))
%      val newB = n.plus(
%        n.mult(this.a, that.b),
%        n.mult(this.b, that.d))
%      val newC = n.plus(
%        n.mult(this.c, that.a),
%        n.mult(this.d, that.c))
%      val newD = n.plus(
%        n.mult(this.c, that.b),
%        n.mult(this.d, that.d))
%      
%       new Matrix2x2[T](newA, newB, newC, newD)
%    }
%  }
% \end{lstlisting-nobreak}

Thanks to this pattern, the duplication of code has been reduced, and we still have collections that offer high-level interface, and generic templates. But, since the |Numeric| also takes generic type parameter, and since it's most likely a primitive type, boxing and unboxing would occur a lot during the operations. This is where the Miniboxing specialization steps in. With a miniboxed version of the |Numeric| class, no boxes are made during the super-class instantiation. The generic classes that are also likely to get primitive types deal therefore only with type primitive, which speeds the runtime up.