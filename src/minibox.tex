\section{Miniboxing Transformation}

This section will present the miniboxing transformation from the Scala compiler's perspective. It will first present the optimization for methods, then dive into objects and finally present the rewiring transformations.

\subsection{Method Transformation}

To start, let us take a simple running example:

\begin{lstlisting-nobreak}
 def identity[T](t: T): T = t
 val x: Int = identity[Int](5)
\end{lstlisting-nobreak}

Under erasure, the low level bytecode looks like:

\begin{lstlisting-nobreak}
 def identity(t: Object): Object = t
 val x: int = `unbox`(identity(`box`(5)))
\end{lstlisting-nobreak}

The low level bytecode of the |identity| method requires a boxed incoming argument and returns a boxed value. The caller then needs to box the argument and unbox the result. In the high level code |Int| is an integer, regardless of its representation. In the low level bytecode, |Int| may be represented as an unboxed integer (|int|) or a boxed integer (|java.lang.Integer|), depending on the context. The |box| and |unbox| represent the conversions from one representation to the other. Hiding the representation makes it easy to program with primitive types, but is a subtle source of performance degradations, as can be seen from this example, which performs boxing under the covers.

In order to recover performance for our example, one approach is to use specialization:

\begin{lstlisting-nobreak}
 def identity[`@specialized` T](t: T): T = t
 val x: Int = identity[Int](5)
\end{lstlisting-nobreak}

Specialization will duplicate the body of |identity| and adapt it for each unboxed primitive. Furthermore, to use the newly created versions of the method, specialization redirects the call from |identity| to |identity_I|, thus avoiding boxing:

\begin{lstlisting-nobreak}
 def identity(t: Object): Object = t
 def identity_V(t: `unit`): `unit` = t
 def identity_Z(t: `boolean`): `boolean` = t
 def identity_B(t: `byte`): `byte` = t
 def identity_C(t: `char`): `char` = t
 def identity_S(t: `short`): `short` = t
 def identity_I(t: `int`): `int` = t
 def identity_J(t: `long`): `long` = t
 def identity_F(t: `float`): `float` = t
 def identity_D(t: `double`): `double` = t
 val x: int = identity_I(5)
\end{lstlisting-nobreak}

Yet, creating all the variants up front does not scale: fully specializing a method or a class with 3 type parameters produces $10^3$ variants of the specialized code, thus bloating the resulting bytecode. A better solution is taken by miniboxing, which gives all primitive types a single representation:

\begin{lstlisting-nobreak}
 // replacing `@specialized` by `@miniboxed`
 def identity(t: Object): Object = t
 def identity_M(`T_Tag: byte`, t: `long`): `long` = t
 val x: int =
     `minibox2int`(identity_M(INT, `int2minibox`(5)))
\end{lstlisting-nobreak}

While this translation looks very similar to boxing, except for the additional |T_Tag|, it is actually much faster: instead of creating an object and using an indirect memory access operation, the |minibox2int| and |int2minibox| operations merely extend the 32-bit integer to a 64-bit long interger and reduce it back. The implementation of this is actually a no-operation on 64-bit x64 processors and is a single instruction on 32-bit x86 processors. This makes the transformation much more efficient than erasure, while avoiding the large bytecode duplication that comes with specialization.

The additional type tag argument deserves an explanation. In the miniboxing representation, all values are encoded as long integers, but unlike fixnums \cite{fixnums-lisp}, all the long integer's bits are necessary to encode the actual data and no bits are left to encode the type. Yet, both in specialization and erasure, the type of the generic data is known: in specialization, there is a 1-to-1 correspondence between the specialized variant being called and the primitive type, while in erasure, the object representation is different for each primitive type, and therefore encodes the type in the object header. The following example shows why encoding the type is necessary:

\begin{lstlisting-nobreak}
 def print[T](t: T) = println(t.toString)
\end{lstlisting-nobreak}

A naive miniboxing translation would generate the following code:

\begin{lstlisting-nobreak}
 def print(t: `long`) = println(`box`(t).toString)
\end{lstlisting-nobreak}

If this code is invoked with a long integer or even an integer, it will correctly output the value. But if if is called for a boolean, such as in |print(true)|, it will print |1| instead of |true|. In order to correctly execute the |toString| operation, the exact type of the generic data must be known. This is where the type tag comes in: it corresponds to the type parameter |T|, thus gets the name |T_Tag|:

\begin{lstlisting-nobreak}
 def print(`T_Tag: byte`, t: long) =
     println(MiniboxUtils.toString(T_Tag, t))
\end{lstlisting-nobreak}

It is worth observing that the type tag is not attached to values but to type parameters. This comes from the fact that in a statically typed language, there is no need to attach types to individual values, like in dynamic languages, but to the type parameters.

The next section will describe the miniboxing translation for classes.

\subsection{Class Transformation}

There are three constraints when tranforming classes with miniboxing: the class fields need to be specailized, so no boxing occurs inside the class, the methods need to be specialized class, such that they do not require boxing and inheritance relations need to be correctly maintained.

To see how the transformation occurs, we can use an example:

\begin{lstlisting-nobreak}
 class A[@miniboxed T](val t: T)
\end{lstlisting-nobreak}

First of all, since |t| is preceeded by |val|, it will be accessible from outside. To make this possible the Scala compiler adds a getter for |t| during typechecking and also makes the |_t| field private to the current instance:

\begin{lstlisting-nobreak}
 class A[@miniboxed T]{
   // class constructor omitted
   private[this] val _t: T
   def t: T = _t
 }
\end{lstlisting-nobreak}

Later in the compilation pipeline, since the type parameter |T| is marked as |@miniboxed|, the class |A| will be transformed into an interface (trait in Scala) with the accessors copied over and transformed for miniboxing:

\begin{lstlisting-nobreak}
 trait A {
   def t: Object
   def t_J(T_Tag: byte): long
 }
\end{lstlisting-nobreak}

The trait |A| will have two instantiations, one for object (called |A_L|) and one for primitive types (called |A_J|):

\begin{lstlisting-nobreak}
 class A_L extends A {
   // class constructor omitted
   private[this] val _t: Object
   def t: Object = _t
   def t_J(T_Tag: byte): long = box2minibox(T_Tag, t)
 }
\end{lstlisting-nobreak}

In the |A_L| class, the field |_t| is an object passed by reference, which is similar to the erasure transformation. Instead, in the |A_J| class, the field is specialized:

\begin{lstlisting-nobreak}
 class A_J extends A {
   // class constructor omitted
   private[this] val _t: long
   private[this] val T_Class_Tag: byte
   def t: Object = minibox2box(T_Tag, t_J(T_Tag))
   def t_J(T_Tag: byte): long = _t
 }
\end{lstlisting-nobreak}

The alert reader may notice a redundancy of tags in the translation of |A_J|: it has both a filed |T_Class_Tag| and a |T_Tag| argument in the |t_J| accessor. However, this is the correct translation, as the |A_L| class, which does not carry a tag, requires a local tag in order to pack its argument into the miniboxed form efficiently. On the other hand, the |A_J| class requires a tag field to enable the |t| accessor, which needs to pack a miniboxed into a boxed representation, therefore needs to have the tag available.

A valid question at this point is why use such a complicated translation instead of leaving the generic class as |A| and overriding it with the specialized class |A_J| which is instantiated for primitive types. We will only briefly mention the reasons and point the reader to \cite{miniboxing} for a full explanation: (1) in such a setup the generic fields from |A| would be inherited into |A_J|, thus bloating the runtime memory requirements and (2) this would break specialized class inheritance:

\begin{lstlisting-nobreak}
 class B[@miniboxed T](t) extends A[T](t)
 // what is the superclass of B_J? B or A_J?
 // if B is an interface => it's A_J
 // if B is a class => no multiple inheritance
\end{lstlisting-nobreak}

The next section will explain how miniboxing does redirects method calls and object creations to their specialized variants.

\subsection{Rewiring}

The previous two sections explained how the miniboxing transformation duplicates and adapts the methods and classes to avoid boxing, but only hinted at how the newly adapted methods and classes are used. This section will tie the knot by describing how the miniboxing transformation redirects method calls and class instantiations. The mechanism is mostly the one specialization \cite{iuli-thesis, specialization-iuli}, with slight changes and to account for the additional tags.

When using miniboxing, the programmer writes code in terms of the generic classes and the miniboxing transformation redirects the uses to the adapted versions. There are two reasons for this decision: (1) for convenience, so the programmer does not reason about the transformations in the compiler and (2) because the redirects performed by miniboxing are both sound (no incorrect redirections are performed) and complete (no redirection opportunity is missed, considering the lack of reified types \cite{michel-thesis, dot-net-generics, dot-net-generics-form} in Scala generics).

The simplest redirection is the method redirection, which was shown in the |identity| example: when type type arguments corresponding to miniboxed type parameters are primitive types, the method can be redirected to a more specific implementation. This simple rule is further refined to account for knowing a type parameter is miniboxed: if a type argument is a primitive type or a miniboxed type parameter, the method call is rewired to the most specific variant. The following example shows this:

\begin{lstlisting-nobreak}
 def printn[T](n: Int, t: T) =
   if (n > 0) {
     println(t.toString)
     printn[T](n - 1, t)
   }
\end{lstlisting-nobreak}

Which is translated to |print_n_times| and |print_n_times_M|, which has the following body:

\begin{lstlisting-nobreak}
 def printn_M(T_Tag: byte, n: int, t: long) =
   if (n > 0) {
     println(MiniboxUtils.toString(T_Tag, t))
     `printn_M(T_Tag, n - 1, t)` // redirected
   }
\end{lstlisting-nobreak}

Object creation is also modified to take primitive types and miniboxed type parameters into account, thus redirecting to the correct miniboxed class. The following example shows this:

\begin{lstlisting-nobreak}
 val a = new A[Int](5)
 val b = new A[String]("x")
\end{lstlisting-nobreak}

The expressions are correct before miniboxing, but do not make sense after the transformation, since |A| becomes an interface. To fix this, the miniboxing transformation redirects object creation:

\begin{lstlisting-nobreak}
 val a = new `A_J`[Int](`INT`, 5)
 val b = new `A_L`[String]("x")
\end{lstlisting-nobreak}

Miniboxed classes introduce another dimension to method redirection, by adding rewiring based on the receiver:

\begin{lstlisting-nobreak}
  a.t // redirected to t_J(INT)
  b.t // left as .t
\end{lstlisting-nobreak}

Finally, the rewiring rule concerns parents. This step actually has two trasnformations. First, an entity extending a miniboxed class and/or miniboxed traits gets its parents rewritten to account for the miniboxed variants. Second, any methods that override methods from miniboxed classes and traits are rewritten according to the class in question:

\begin{lstlisting-nobreak}
  class B[@miniboxed T]   { def foo: T = ??? }
  class C extends B[Int] { override def foo = 5 }
\end{lstlisting-nobreak}

This example is rewritten to:

\begin{lstlisting-nobreak}
  trait B {
    def foo: T
    def foo_J: long
  }
  // classes B_L and B_J omitted
  class C extends B_J {
    override def foo_J = minibox2int(5)
  }
\end{lstlisting-nobreak}

This concludes the explanation of the miniboxing transformation from the compiler's perspective. The next chapter presents the transformation from the programmer's perspective.
