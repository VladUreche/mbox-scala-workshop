\section{Introduction}

\topic{Scala collections allow storing data} in an abstract and type-safe manner. This is done using generics, which allow treating types as parameters of classes and methods. Using generics, it is possible to abstract over the type of the data in a collection, such as, for example, creating a linked list of integers. Safety is then guaranteed by the type system, which can guarantee all elements of the collection are actually integers. This increases productivity and improves code quality.

Generics are currently translated to low level bytecode using the technique of erasure \cite{java-erasure}. This entails that all type parameters are replaced by their lower bound, which is usually |Object|. As an advantage, it makes everything uniform, since everything is treated as a reference. However, since generics are represented as references, the type parameters cannot be directly instantiated by primitve types, such as integers or floating point numbers. Instead, an object representation of the primitive type must be used. This is done by wrapping primitive values into objects, in a process is called boxing. The opposite process, which extracts the primitive value from an object, is called unboxing. Boxing and unboxing degrade program performance, inflate the heap memory requirements and trigger extra garbage collection cycles.

\topic{Miniboxing \cite{miniboxing} is an alternative translation for generics,} which avoids boxing and unboxing, thus improving the performance for primitive types. This is done by creating additional versions of the generic methods and classes which accept primitive values as arguments and return primitive types. Instead of creating an additional version for each primitive type, which would be wasteful in terms of bytecode size, miniboxing creates a single version which can encode all primitive types. We call these additional versions of methods and classes specialized variants. Therefore, in the case of miniboxing, for a single type parameter, there will be two variants of a method or class: one using the erasure-based translation, which is used for objects, and a specialized one, for primitive types.

\topic{Scala collections expose a simple and high-level interface.} This is done by allowing programmers to effortlessly transform collections by mapping over their elements, filtering them or splitting collections based on custom criteria. All these features make heavy use of generics and are thus affected by slowdons when used with primitive types. This makes Scala collections unsuitable for numeric processing applications, such as machine learning, statistics or bioinformatics.

\topic{This leads to the idea of translating Scala collections} using the miniboxing transformation in order to reap the benefits of the convenient high-level interface while offering good performance for numeric applications. Yet this is not an easy task: collections are implemented using multiple layers of functionality and use complex patterns in order to reduce code duplication and gain flexibility.

\topic{In this paper, we set out to use the miniboxing transformation on a mock-up of the Scala collections,} which includes all the relevant patterns used in the real collections. In this context, we make the following contributions:

\begin{packed_item}
\item we explain the patterns used to implement the Scala collections;
\item we show how the miniboxing transformation transforms each pattern;
\item finally, we benchmark our mock-up of the Scala collections using the miniboxing transformation.
\end{packed_item}

The paper first describes the miniboxing transformation, implemented as a plugin for the Scala compiler, then describes the patterns used in implementing Scala collections and how they are transformed by miniboxing and finally presents our mockup collections and the benchmark results.